function getConstants() {
    return {
        hands: [
            ['Lose', 0],
            ['Jacks or Better', 1],
            ['Two Pair', 2],
            ['Three of a Kind', 3],
            ['Straight', 4],
            ['Flush', 6],
            ['Full House', 9],
            ['Four of a Kind', 25],
            ['Straight Flush', 50],
            ['Royal Flush', 800],
        ],
        ranks: [
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            't',
            'j',
            'q',
            'k',
            'a',
        ],
        suits: ['s', 'h', 'c', 'd'],
        colors: {
            's': '#1F191B',
            'c': '#1F191B',
            'h': '#CB1728',
            'd': '#CB1728',
        },
        stringMap: {
            'as': 'ðŸ‚¡',
            'ah': 'ðŸ‚±',
            'ad': 'ðŸƒ',
            'ac': 'ðŸƒ‘',
            '2s': 'ðŸ‚¢',
            '2h': 'ðŸ‚²',
            '2d': 'ðŸƒ‚',
            '2c': 'ðŸƒ’',
            '3s': 'ðŸ‚£',
            '3h': 'ðŸ‚³',
            '3d': 'ðŸƒƒ',
            '3c': 'ðŸƒ“',
            '4s': 'ðŸ‚¤',
            '4h': 'ðŸ‚´',
            '4d': 'ðŸƒ„',
            '4c': 'ðŸƒ”',
            '5s': 'ðŸ‚¥',
            '5h': 'ðŸ‚µ',
            '5d': 'ðŸƒ…',
            '5c': 'ðŸƒ•',
            '6s': 'ðŸ‚¦',
            '6h': 'ðŸ‚¶',
            '6d': 'ðŸƒ†',
            '6c': 'ðŸƒ–',
            '7s': 'ðŸ‚§',
            '7h': 'ðŸ‚·',
            '7d': 'ðŸƒ‡',
            '7c': 'ðŸƒ—',
            '8s': 'ðŸ‚¨',
            '8h': 'ðŸ‚¸',
            '8d': 'ðŸƒˆ',
            '8c': 'ðŸƒ˜',
            '9s': 'ðŸ‚©',
            '9h': 'ðŸ‚¹',
            '9d': 'ðŸƒ‰',
            '9c': 'ðŸƒ™',
            'ts': 'ðŸ‚ª',
            'th': 'ðŸ‚º',
            'td': 'ðŸƒŠ',
            'tc': 'ðŸƒš',
            'js': 'ðŸ‚«',
            'jh': 'ðŸ‚»',
            'jd': 'ðŸƒ‹',
            'jc': 'ðŸƒ›',
            'qs': 'ðŸ‚­',
            'qh': 'ðŸ‚½',
            'qd': 'ðŸƒ',
            'qc': 'ðŸƒ',
            'ks': 'ðŸ‚®',
            'kh': 'ðŸ‚¾',
            'kd': 'ðŸƒŽ',
            'kc': 'ðŸƒž',
        },
    };
}

function createGame(keyboard, cardBlock) {}

const world = createWorld();
const keyboard = createKeyboard();

const [cw, ch] = world.getBounds();
const cardH = Math.round(ch * 0.3);
const cardBlock = createCardBlock(cardH, cw, cardH);
world.add(cardBlock);
// const coinBlock = createBetBlock(100, 100, 50);
// world.add(coinBlock);
const balanceTF = createTextView('', cw / 2, cardH / 3, {
    fill: 'white',
    fontSize: 42,
});
world.add(balanceTF);

const infoTF = createTextView('', cw / 2, cardH / 1.5, {
    fill: 'white',
    fontSize: 42,
});
world.add(infoTF);

let bet = 1;
let balance = 404;
let deck;
let cardsToReplace;
let isComplete;
let lockKeyboard;

startRound();

function startRound() {
    const isInit = !lockKeyboard;
    if (!isInit) {
        lockKeyboard();
    }
    isComplete = false;
    cardsToReplace = [];
    balance -= bet;
    deck = createDeck();
    const cards = deck.deal(5);
    cardBlock.setCards(cards, isInit).then(() => {
        lockKeyboard = keyboard.subscribe(onKey);
    });
    balanceTF.setText(`Balance: ${balance}`);
    infoTF.setText('');
}

// function changeBet(add) {
//     const b = bet + add;
//     if (b === 0 || b > 5) {
//         return;
//     }
//     bet = b;
//     if (add > 0) {
//         coinBlock.addCoin();
//     } else {
//         coinBlock.removeCoin();
//     }
// }

function placeBet() {
    isComplete = true;
    const crds = cardBlock.getCards();
    const [name, win] = rateHand(crds);
    balance += win;
    console.log(name, win, balance);
    balanceTF.setText(`Balance: ${balance}`);
    if (win) {
        infoTF.setText(`${name}, win ${win}`);
    } else {
        infoTF.setText('Better luck next time');
    }
}

function prepareDraw(index) {
    const i = cardsToReplace.indexOf(index);
    if (i === -1) {
        cardsToReplace.push(index);
        cardBlock.selectCard(index);
    }
}

function onKey(e) {
    if (!isComplete && e.isDigit && e.digit > 0 && e.digit < 6) {
        prepareDraw(e.digit - 1);
    } else if (e.isSpace) {
        if (isComplete) {
            startRound();
        } else if (cardsToReplace.length) {
            const drawCards = deck.deal(cardsToReplace.length);
            const drawData = cardsToReplace.map((index, i) => [
                index,
                drawCards[i],
            ]);
            cardBlock.replaceCards(drawData);
            placeBet();
        } else {
            placeBet();
        }
    }
    // else if (e.isPlus) {
    //     changeBet(1);
    // } else if (e.isMinus) {
    //     changeBet(-1);
    // }
}

function createKeyboard() {
    let listeners = {};
    let keys = [];

    window.addEventListener('keyup', handleKeyUp);

    return {
        subscribe,
        reset,
    };

    function reset() {
        listeners = {};
        keys = [];
    }

    function handleKeyUp(e) {
        const dig = Number(e.key);
        const event = {};
        if (isSpace(e.key)) {
            event.isSpace = true;
        } else if (isPlus(e.key)) {
            event.isPlus = true;
        } else if (isMinus(e.key)) {
            event.isMinus = true;
        } else if (isDigit(dig)) {
            event.digit = dig;
            event.isDigit = true;
        } else {
            event[`is${e.key}`] = true;
        }
        keys.forEach((key) => listeners[key] && listeners[key](event));
    }

    function subscribe(listener) {
        const key = Date.now();
        listeners[key] = listener;
        keys = Object.keys(listeners);

        return function () {
            delete listeners[key];
            keys = Object.keys(listeners);
        };
    }

    function isDigit(value) {
        return Number.isInteger(value);
    }

    function isSpace(value) {
        return value === ' ';
    }

    function isPlus(value) {
        return value === '+';
    }

    function isMinus(value) {
        return value === '-';
    }
}

function createWorld() {
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    let objects = [];
    let dynamicObjects = [];

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.lineJoin = 'round';

    requestAnimationFrame(loop);

    return {
        getBounds,
        add,
        reset,
    };

    function getBounds() {
        return [canvas.width, canvas.height];
    }

    function add(obj) {
        obj.setContext(ctx);
        objects.push(obj);
        if (typeof obj.update === 'function') {
            dynamicObjects.push(obj);
        }
    }

    function reset() {
        objects = [];
        dynamicObjects = [];
    }

    function loop(t) {
        update(t);
        clear();
        render();
        requestAnimationFrame(loop);
    }

    function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function update(t) {
        dynamicObjects.forEach((obj) => obj.update(t));
    }

    function render() {
        objects.forEach((obj) => obj.render());
    }
}

function createCard(rank, suit) {
    const { stringMap, ranks, colors } = getConstants();
    return {
        rank,
        suit,
        value: ranks.indexOf(rank),
        string: stringMap[rank + suit],
        color: colors[suit],
    };
}

function createDeck() {
    const { suits, ranks } = getConstants();
    const cards = suits.reduce((result, suit) => {
        const cardsWithRank = ranks.map((rank) => createCard(rank, suit));
        return [...result, ...cardsWithRank];
    }, []);

    for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
    }

    function deal(num) {
        return cards.splice(num * -1);
    }

    return { deal };
}

function rateHand(cards) {
    const { hands } = getConstants();
    const pool = [...cards].sort(valueComparator);
    let isStraight = true;
    let isFlush = true;

    const kinds = pool.reduce((result, card, index) => {
        if (isStraight && index !== 0) {
            isStraight = card.value === pool[index - 1].value - 1;
        }
        if (isFlush && index !== 0) {
            isFlush = card.suit === pool[index - 1].suit;
        }
        if (result[card.rank]) {
            result[card.rank].push(card);
        } else {
            result[card.rank] = [card];
        }
        return result;
    }, {});

    let rate = hands[0];

    const isStraightFlush = isFlush && isStraight;
    const isRoyalFlush = isStraightFlush && kinds.a && kinds.a.length === 1;
    if (isRoyalFlush) {
        rate = hands[9];
    } else if (isStraightFlush) {
        rate = hands[8];
    } else if (isFlush) {
        rate = hands[5];
    } else if (isStraight) {
        rate = hands[4];
    } else {
        const rb /* repetition buckets*/ = Object.keys(kinds).reduce(
            (result, rank) => {
                const len = kinds[rank].length;
                result[len].push(kinds[rank]);
                return result;
            },
            { '1': [], '2': [], '3': [], '4': [] }
        );

        if (rb['4'].length === 1) {
            rate = hands[7];
        } else if (rb['2'].length === 1 && rb['3'].length === 1) {
            rate = hands[6];
        } else if (rb['3'].length === 1) {
            rate = hands[3];
        } else if (rb['2'].length === 2) {
            rate = hands[2];
        } else if (rb['2'].length === 1) {
            const isBetter = rb['2'][0].every((card) => card.value > 8);
            if (isBetter) {
                rate = hands[1];
            }
        }
    }

    return rate;

    function valueComparator(card1, card2) {
        if (card1.value < card2.value) {
            return 1;
        }
        if (card1.value > card2.value) {
            return -1;
        }
        return 0;
    }
}

function createBetBlock(x, y, r) {
    let ctx;
    const gap = Math.round(r * 0.1);
    const coinsViews = [createCoinView(x, y, r)];

    return {
        setContext,
        render,
        addCoin,
        removeCoin,
    };

    function addCoin() {
        const cx = x + coinsViews.length * (2 * r + gap);
        const coinView = createCoinView(cx, y, r);
        coinView.setContext(ctx);
        coinsViews.push(coinView);
    }

    function removeCoin() {
        coinsViews.pop();
    }

    function render() {
        coinsViews.forEach((view) => view.render());
    }

    function setContext(c) {
        ctx = c;
        coinsViews.forEach((view) => view.setContext(c));
    }
}

function createCardBlock(cardHeight, canvasWidth, y) {
    let ctx;
    let cardViews = [];
    const margin = Math.round(cardHeight * 0.06);
    const cardWidth = Math.round(cardHeight * 0.66);

    return {
        setContext,
        render,
        selectCard,
        replaceCards,
        getCards,
        setCards,
    };

    function setCards(cards, isInit) {
        const delay = isInit ? 2000 : 500;
        const bw = margin + cards.length * (cardWidth + margin);
        const x = (canvasWidth - bw) / 2;
        cardViews = cards.map((card, i) => {
            const cx = x + i * (cardWidth + margin);
            const view = createCardView(
                card,
                cx,
                y,
                cardWidth,
                cardHeight,
                margin
            );
            view.setSelected(true);
            return view;
        });
        cardViews.forEach((view) => view.setContext(ctx));

        return new Promise((resolve) => {
            setTimeout(() => {
                cardViews.forEach((view) => view.setSelected(false));
                resolve();
            }, delay);
        });
    }

    function render() {
        cardViews.forEach((view) => view.render());
    }

    function setContext(c) {
        ctx = c;
    }

    function selectCard(index) {
        cardViews[index].setSelected(true);
    }

    function replaceCards(drawData) {
        drawData.forEach(([index, card]) => {
            cardViews[index].setCard(card);
            cardViews[index].setSelected(false);
        });
    }

    function getCards() {
        return cardViews.map((view) => view.getCard());
    }
}

function createCardView(card, x, y, w, h, margin) {
    let ctx;
    let isSelected;
    const back = 'ðŸ‚¿';

    return {
        render,
        setContext,
        setSelected,
        setCard,
        getCard,
    };

    function render() {
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.fillRect(x, y, w, h - margin / 2);
        ctx.font = `${h}px sans-serif`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.fillStyle = isSelected ? '#DCB600' : card.color;
        const text = isSelected ? back : card.string;
        ctx.fillText(text, x, y + margin);

        ctx.restore();
    }

    function setCard(cd) {
        card = cd;
    }

    function getCard() {
        return card;
    }

    function setSelected(isSel) {
        isSelected = isSel;
    }

    function setContext(c) {
        ctx = c;
    }
}

function createCoinView(x, y, r) {
    let ctx;

    return {
        render,
        setContext,
    };

    function render() {
        ctx.save();
        ctx.strokeStyle = 'green';
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.font = `bold ${r * 2}px sans-serif`;
        ctx.fillStyle = 'white';
        ctx.fillText('$', x, y + 5);
        ctx.strokeText('$', x, y + 5);

        ctx.restore();
    }

    function setContext(c) {
        ctx = c;
    }
}

function createTextView(text, x, y, style) {
    let ctx;
    const { fontSize, fill, stroke } = style;

    return {
        render,
        setContext,
        setText,
    };

    function setText(t) {
        text = t;
    }

    function render() {
        ctx.save();
        ctx.font = `${fontSize}px fantasy`;
        ctx.fillStyle = fill;
        ctx.fillText(text, x, y);
        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.strokeText(text, x, y);
        }
        ctx.restore();
    }

    function setContext(c) {
        ctx = c;
    }
}
